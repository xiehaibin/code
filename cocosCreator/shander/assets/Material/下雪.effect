// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;
  
  #include <alpha-test>
  #include <texture>
  #include <cc-global>
  #include <cc-local>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif

  const float layerCount = 10.0;
  float uv_y = 0.0;

  float DrawCircle(vec2 uv, vec2 offset, vec2 size, vec2 ssMinMax)
  {
    uv -= 0.5;
    uv -= offset;
    uv /= size;
    float circle = 1.0- length(uv) * 2.0;
    return smoothstep(ssMinMax.x, ssMinMax.y, circle);
  }

  vec2 Hash22(vec2 val)
  {
    //fract 获取x的小数部分
    float x = fract(sin(dot(val * 62.1, vec2(127.1, 311.7))) * 43758.5453123);
    float y = fract(sin(dot(val , vec2(12.9898, 78.233))) * 3758.547);
    return vec2(x, y);
  }

  float Hash12(vec2 p)
  {
    vec3 p3  = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
  }

  float Hash11(float p)
  {
    vec3 p3 = fract(vec3(p,p,p) * 0.10310);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z); 
  }

  float Remap(float oa, float ob, float na, float nb, float val)
  {
	  return (val-oa)/(ob-oa) * (nb-na) + na;
  }

  float drawSnowLayer(vec2 uv, float layerId)
  {
      float hash1 = Hash11(layerId);

      uv *= (2.0 + layerId);
      uv.x += sin(cc_time.x)*0.1;
      uv.y -= (cc_time.x*0.6 + hash1*0.8)*0.8;
      vec2 gridId = floor(uv);
      uv = fract(uv);

      uv_y = uv.y;
    
      vec2 offset = (Hash22(gridId) - 0.5)*0.3;
      float hash2 = Hash12(gridId);
      vec2 size = 0.05 + mix(vec2(0.1, 0.1), vec2(0.2, 0.2), hash2) * 1.0;

      float lightPeroidVal = (sin(cc_time.x + hash2*6.28) * 0.5 + 0.5);
      float light = mix(0.6, 0.8, lightPeroidVal) * pow((1.0 - layerId/layerCount), 1.0);

      float c = DrawCircle(uv, offset, size, vec2(0.5, 1.5)) * light * 6.0;

      return c;
  }

  void main () 
  {
    vec4 o = vec4(1, 1, 1, 1);

    vec2 uv = v_uv0;

    float c = 0.0;
    for (float i = 0.0; i < layerCount; i++)
    {
      c = max(c, drawSnowLayer(uv, i));
    }

    if (c > 0.0)
      o = vec4(1.0, 1.0, 1.0, c ); //- (1.0-uv.y) + 0.4
    else
      o = vec4(c, c, c, 0.0);

    o *= v_color;

    ALPHA_TEST(o);

    gl_FragColor = o;
  }
}%
