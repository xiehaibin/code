// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
        
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%

CCProgram fs %{
  precision highp float;
  
  #include <alpha-test>
  #include <texture>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif

  // 像素化
  vec2 pixelate(vec2 uv, float _PixelateSize)
  {
    return floor(uv*_PixelateSize)/_PixelateSize;
  }
  // 模糊
  vec4 blur(sampler2D sam, vec2 rawUV, float offset)
  {
    vec2 divi[12];
    divi[0] = vec2(-0.326212, -0.40581);
    divi[1] = vec2(-0.840144, -0.07358);
    divi[2] = vec2(-0.695914, 0.457137);
    divi[3] = vec2(-0.203345, 0.620716);
    divi[4] = vec2(0.96234, -0.194983);
    divi[5] = vec2(0.473434, -0.480026);
    divi[6] = vec2(0.519456, 0.767022);
    divi[7] = vec2(0.185461, -0.893124);
    divi[8] = vec2(0.507431, 0.064425);
    divi[9] = vec2(0.89642, 0.412458);
    divi[10] = vec2(-0.32194, -0.932615);
    divi[11] = vec2(-0.791559, -0.59771);
  

    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);
    for(int i=0; i<12; i++)
    {
      vec2 uv = rawUV + offset * divi[i];
      uv = clamp(uv, 0.0, 1.0);
      vec4 c = texture2D(sam, uv);
      col += c;
    }
    col = col/12.0;  //vec4(col.rgb/12.0, col.a);
    return col;
  }

  // 2D 阴影
  vec4 shadow2D(vec4 rawCol, sampler2D tex, vec2 uv, vec2 shadowOffset, vec4 shadowColor)
  {
      float shadowA = texture2D(tex, uv + shadowOffset).a;
      rawCol.rgb = mix((shadowColor.rgb * shadowA), rawCol.rgb, rawCol.a);
      rawCol.a = max(shadowA * shadowColor.a, rawCol.a); 
      return rawCol;
  }

  // 色差
  vec4 chromaticAberration(vec4 rawCol, sampler2D tex, vec2 uv, vec4 tintColor, float factor, float alpha)
  {
    vec4 r = texture2D(tex, uv + vec2(factor, 0)) * tintColor;
    vec4 b = texture2D(tex, uv + vec2(-factor, 0)) * tintColor;
    return vec4(r.r * r.a, rawCol.g, b.b * b.a, max(max(r.a, b.a) * alpha, rawCol.a)); 
  }


  // 获取边界值
  float getBorderAlpha(sampler2D tex, vec2 uv, float offset)
  {
    float spriteLeft = texture2D(tex, uv + vec2(offset, 0.0)).a;
    float spriteRight = texture2D(tex, uv - vec2(offset, 0.0)).a;
    float spriteBottom = texture2D(tex, uv + vec2(0.0, offset)).a;
    float spriteTop = texture2D(tex, uv - vec2(0.0, offset)).a;
    float result = spriteLeft + spriteRight + spriteBottom + spriteTop;

    float spriteTopLeft = texture2D(tex, uv + vec2(offset, offset)).a;
    float spriteTopRight = texture2D(tex, uv + vec2(-offset, offset)).a;
    float spriteBotLeft = texture2D(tex, uv + vec2(offset, -offset)).a;
    float spriteBotRight = texture2D(tex, uv + vec2(-offset, -offset)).a;
    result = result + spriteTopLeft + spriteTopRight + spriteBotLeft + spriteBotRight;

    return result;
  }

  vec3 getPixel(float offsetX, float offsetY, vec2 uv, sampler2D tex)
  {
    return texture2D(tex, (uv + vec2(offsetX, offsetY))).rgb;
  }

  // 内部描边
  vec4 drawInnerOutline(vec4 rawCol, sampler2D tex, vec2 uv, vec4 outlineColor, float width, float alpha, float glow)
  {
    vec3 col = abs(getPixel(0.0, width, uv, tex) - getPixel(0.0, -width, uv, tex));
    col += abs(getPixel(width, 0.0, uv, tex) - getPixel(-width, 0.0, uv, tex));
    col *= rawCol.a * alpha;
    float outlineVal =  length(col) * glow;
    rawCol.rgb = mix(rawCol.rgb, outlineColor.rgb, outlineVal);
    return rawCol;
  }
  // 外部描边
  vec4 drawOutline(vec4 rawCol, sampler2D tex, vec2 uv, vec4 outlineColor, float width, float alpha, float glow)
  {
    float result = getBorderAlpha(tex, uv, width);
    result = step(0.01, result);
    result *= (1.0 - rawCol.a) * alpha;
    vec4 outline = result * outlineColor;
    outline.rgb *= glow * 2.0;
    return mix(outline, rawCol, rawCol.a);
  }

  // 对比度
  vec4 contrast(vec4 color, vec4 blurred, float intensity, float threshold)
  {
    vec4 difference = color - blurred;
    vec4 signs = sign(difference);
    
    vec4 enhancement = clamp(abs(difference) - threshold, 0.0, 1.0) * signs * 1.0/(1.0-threshold);
    color += enhancement * intensity;
    
    return color;
  }

  //黑白
  vec4 oldPhoto(vec4 color, float rate)
  {
    float y = dot(vec3(0.299, 0.587, 0.114), color.rgb);
    
    vec4 sepiaConvert = vec4(0.191, -0.0540, -0.221, 0.0);
    sepiaConvert = sepiaConvert + y;
    sepiaConvert.a = color.a;
    return mix(color, sepiaConvert, rate);
  }

  void main () 
  {
    vec4 o = vec4(1, 1, 1, 1);

    // 像素化
    //vec2 uv = pixelate(v_uv0, 3.0);
    //CCTexture(texture, uv, o);

    // 模糊
    //vec4 o2 = blur(texture, vec2(v_uv0.xy), 0.003);
    //CCTexture(texture, v_uv0, o);
    //o2 *= o.a;
    //o = o2;

    // 阴影
    //CCTexture(texture, v_uv0, o);
    //o = shadow2D(o, texture, v_uv0, vec2(0.008, 0.005), vec4(0.0, 0.0, 0.0, 1.0));

    // 色差
    //CCTexture(texture, v_uv0, o);
    //o = chromaticAberration(o, texture, v_uv0, vec4(1.0, 0.0, 1.0, 1.0), 0.015, 0.5);

    //外部描边
    //CCTexture(texture, v_uv0, o);
    //o = drawOutline(o, texture, v_uv0, vec4(1.0, 0.0, 0.0, 1.0), 0.001, 1.0, 6.0);
    //o = drawInnerOutline(o, texture, v_uv0, vec4(1.0, 0.0, 0.0, 1.0), 0.0005, 1.0, 2.0);

    //CCTexture(texture, v_uv0, o);
    //o = oldPhoto(o, 1.5);

    CCTexture(texture, v_uv0, o);
    o = contrast(o, vec4(1.0, 0, 0, 1.0), 0.2, 0.2);

    ALPHA_TEST(o);

    gl_FragColor = o;
  }
}%
